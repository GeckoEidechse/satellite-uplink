<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Satellite Uplink</title>

  <!-- Bootstrap CSS -->
  <!-- TODO delete <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"> -->

  <!-- Local stylesheet -->
  <link href="styles.css" type="text/css" rel="stylesheet">
</head>

<body>
  <div id="channel_trees">
    <div id="lobby">Waiting<ul id="lobby_userlist"></ul>
    </div>
    <div id="team_a" class="teams">Militia<ul id="team_a_userlist"></ul>
    </div>
    <div id="team_b" class="teams">IMC<ul id="team_b_userlist"></ul>
    </div>
  </div>

  <div class="footer">Source on <a href="https://gitlab.com/GeckoEidechse/satellite-uplink">Gitlab</a></div>
  <!-- jQuery -->
  <script src="jquery.min.js"></script>
  <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script> -->

  <!-- Socket Library -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    var ordnances_selection_html_string = '';
    var titans_selection_html_string = '';
    var socket = io();

    function get_image_tag(user) {
      if (user.avatar)
        var url = "https://cdn.discordapp.com/avatars/" + user.id + "/" + user.avatar + ".png?size=256";
      else
        // If user has no icon, use default
        var url = "https://discord.com/assets/dd4dbc0016779df1378e7812eabaa04d" + ".png?size=256";

      let tag = " <img src=\"" + url + "\" alt=\"(" + user.name + "'s avatar)\" style=\"border-radius: 50%; width: 30px\"> "
      return tag;
    }

    function update_ordnance(select) {
      var ordnance_update = {
        ordnance: select.options[select.selectedIndex].value,
        user_id: select.parentElement.id
      }
      socket.emit('update ordnance', ordnance_update);
    }
    function update_titan(select) {
      var titan_update = {
        titan: select.options[select.selectedIndex].value,
        user_id: select.parentElement.id
      }
      socket.emit('update titan', titan_update);
    }

    // Call when channel tree has changed
    socket.on('update channel tree', function (channel_tree, user_to_ordnance_string, user_to_titan_string) {
      console.debug("Received data:");
      console.debug(channel_tree);

      // Make maps from the received strings created from maps
      var user_to_ordnance = new Map(JSON.parse(user_to_ordnance_string));
      var user_to_titan = new Map(JSON.parse(user_to_titan_string));

      // Clear previous content
      $('#lobby_userlist').html("");
      $('#team_a_userlist').html("");
      $('#team_b_userlist').html("");

      // Sort channel list
      channel_tree.channel_lobby.users.sort((a, b) => a.name.localeCompare(b.name));
      channel_tree.channel_a.users.sort((a, b) => a.name.localeCompare(b.name));
      channel_tree.channel_b.users.sort((a, b) => a.name.localeCompare(b.name));

      // Update list for each user
      for (const user of channel_tree.channel_lobby.users) {
        $('#lobby_userlist').append("<li class=\"user\">" + get_image_tag(user) + user.name + "</li>");
      }
      for (const user of channel_tree.channel_a.users) {
        $('#team_a_userlist').append("<li class=\"user\" id=\"" + user.id + "\">" + ordnances_selection_html_string + titans_selection_html_string + get_image_tag(user) + user.name + "</li>");
      }
      for (const user of channel_tree.channel_b.users) {
        $('#team_b_userlist').append("<li class=\"user\" id=\"" + user.id + "\">" + ordnances_selection_html_string + titans_selection_html_string + get_image_tag(user) + user.name + "</li>");
      }
      // Set the according selection for the according users
      for (const [key, value] of user_to_ordnance.entries()) {
        document.getElementById(key).childNodes[1].value = value; // TODO: don't statically assume the wanted child is the second elem in list
      }
      for (const [key, value] of user_to_titan.entries()) {
        document.getElementById(key).childNodes[3].value = value; // TODO: don't statically assume the wanted child is the second elem in list
      }
    });

    function get_html_selection_string(name, id, options) {
      // Creates HTML string that contains list of `options`

      var selection_html_string = '<label>' + name + '</label><select onchange="update_' + id + '(this)">';
      // Add default empty selection
      selection_html_string += '<option value="not_selected">not_selected</option>';
      for (const option of options) {
        selection_html_string += '<option value="' + option.id + '">' + option.id + '</option>';
      }
      // Close tag
      selection_html_string += '</select>';
      return selection_html_string;
    }

    // Load ruleset
    var url = '/rules.json';
    var rules = {};
    $.ajax({
      type: 'GET',
      url: url,
      dataType: 'json',
      success: function (data) { rules = data; },
      async: false
    });

    // Apply rules
    ordnances_selection_html_string = get_html_selection_string('Ordnance', 'ordnance', rules.ordnances);
    titans_selection_html_string = get_html_selection_string('Titan', 'titan', rules.titans);

    // Get channel tree and selections on load
    window.onload = socket.emit('new client');
  </script>
</body>

</html>