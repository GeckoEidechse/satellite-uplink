<!DOCTYPE html>

<head>
  <meta charset="utf-8">

  <!-- Makes flexboxes look decent on mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />

  <title>Satellite Uplink</title>

  <!-- Icon-->
  <link rel="icon" href="/images/icons/favicon-circle.png">

  <!-- Local stylesheet -->
  <link href="styles.css" type="text/css" rel="stylesheet">
</head>

<body>
  <div id="page-container">
    <div id="content-wrap">
      <div id="channel_trees"></div>

      <div id="callout_container">
        <button class="dropbtn" onclick="toggle_callout_display('basic');">Show basic callouts</button>
        <button class="dropbtn" onclick="toggle_callout_display('full');">Show full callouts</button>
        <button class="dropbtn" onclick="toggle_callout_display('');">Clear callouts</button>
        <div id="inner_callout_container">
        </div>
      </div>
    </div>

    <div class="footer">Source on <a href="https://gitlab.com/GeckoEidechse/satellite-uplink">Gitlab</a></div>
  </div>

  <!-- jQuery -->
  <script src="jquery.min.js"></script>

  <!-- Socket Library -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    function toggle_callout_display(callout_type) {
      // Clear HTML element
      $('#inner_callout_container').html("");
      // Add iframe if appropriate button is pressed
      if (callout_type == "basic") {
        $('#inner_callout_container').append('<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSLW9PFz6kfB7F1TJnXY1uHnZLi89bExHlYRTgLcGOE6fJi6t23Cs5xKEqCGYYE_llgdUsBmYVdZTLf/embed?start=false&loop=false&delayms=3000" frameborder="0" width="960" height="569" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>');
      }
      if (callout_type == "full") {
        $('#inner_callout_container').append('<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTvuwVzSbumH9uWgYxMVSfTOxzpzehRQlS9g9CQ8NFAHdGynYiQprnV5XXGznnxVBdjISy-dDNy3OkF/embed?start=false&loop=false&delayms=3000" frameborder="0" width="960" height="569" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>');
      }
    }
    var ordnances_selection_html_string = '';
    var titans_selection_html_string = '';
    var socket = io();

    function get_image_tag(user) {
      /* Returns the string of an HTML image element containing the users avatar */
      if (user.avatar)
        var url = "https://cdn.discordapp.com/avatars/" + user.id + "/" + user.avatar + ".png?size=256";
      else
        // If user has no icon, use default
        var url = "https://discord.com/assets/dd4dbc0016779df1378e7812eabaa04d" + ".png?size=256";

      let tag = " <img src=\"" + url + "\" alt=\"(" + user.name + "'s avatar)\" style=\"border-radius: 50%; width: 30px\"> "
      return tag;
    }

    function update_ordnance(select) {
      /* Sends a message to the server with the user selected ordnance */
      var ordnance_update = {
        ordnance: select.classList[0],
        user_id: String(select.parentElement.parentElement.parentElement.id)
      }
      socket.emit('update ordnance', ordnance_update);
    }
    function update_titan(select) {
      /* Sends a message to the server with the user selected titan */
      var titan_update = {
        titan: select.classList[0],
        user_id: String(select.parentElement.parentElement.parentElement.id)
      }
      socket.emit('update titan', titan_update);
    }

    function decrement_available(selection, id) {
      /* Decrement times a choice is available by one */
      if (selection.id == id && selection.max_per_team != null) {
        var result = {
          "id": selection.id,
          "name": selection.name,
          "max_per_team": selection.max_per_team - 1
        };
        return result;
      }
      else
        return selection;
    }

    function get_current_available(channel_users, user_to_ordnance, user_to_titan) {
      /* Get currently available choices based on ruleset and selections */
      // Clone object
      var rules_copy = jQuery.extend(true, {}, rules);
      for (const user of channel_users) {
        // Ordnance
        let ordnance_selection = user_to_ordnance.get(user.id);
        if (ordnance_selection) { // Only run if user selected something
          // Remove the selection from available
          rules_copy.ordnances = rules_copy.ordnances.map(
            function (element) {
              return decrement_available(element, ordnance_selection);
            }
          );
        }
        // Titan
        let titan_selection = user_to_titan.get(user.id);
        if (titan_selection) { // Only run if user selected something
          // Remove the selection from available
          rules_copy.titans = rules_copy.titans.map(
            function (element) {
              return decrement_available(element, titan_selection);
            }
          );
        }
      }
      return rules_copy;
    }

    function display_available_for_channel(channel_users, html_object_id, user_to_ordnance, user_to_titan) {
      /* Display available options based on ruleset and selections */

      // Get currently available choices
      var rules_copy = get_current_available(channel_users, user_to_ordnance, user_to_titan);

      // Create HTML string containing elements representing available choices
      var available_html_string = '';
      available_html_string += '<hr />' + '<b>Available:</b>' + '<br />' + '<div style="display: flex;">';
      for (const ordnance of rules_copy.ordnances) {
        if (ordnance.max_per_team > 0 || ordnance.max_per_team == null) {
          available_html_string += '<div style="margin: 1px">' + '<img src="/images/icons/ordnances/' + ordnance.id + '.png" alt="' + ordnance.name + '" title="' + ordnance.name + '" width="30px" height="30px" style="border-radius: 15%;"></img> ' + '</div>';
        }
      }
      available_html_string += '</div>' + '<div style="display: flex;">'
      for (const titan of rules_copy.titans) {
        if (titan.max_per_team > 0 || titan.max_per_team == null) {
          available_html_string += '<div style="margin: 1px">' + '<img src="/images/icons/titans/' + titan.id + '.png" alt="' + titan.name + '" title="' + titan.name + '" width="30px" height="30px"></img> ' + '</div>';
        }
      }
      available_html_string += '</div>';

      // Clear content
      $(html_object_id).html("");

      // Redraw
      $(html_object_id).append(available_html_string);

      // Show warnings if there is too many of a certain selection
      for (const item of [rules_copy.ordnances, rules_copy.titans]) {
        for (const choice of item) {
          if (choice.max_per_team < 0 && choice.max_per_team != null) {
            $(html_object_id).append('<p style="color: red">Too many: ' + choice.name + ' !</p>');
          }
        }
      }
    }

    // Call when channel tree has changed
    socket.on('update channel tree', function (channel_tree, user_to_ordnance_string, user_to_titan_string) {
      /* Redraw channel tree if there have been changes */

      // Make maps from the received strings created from maps
      var user_to_ordnance = new Map(JSON.parse(user_to_ordnance_string));
      var user_to_titan = new Map(JSON.parse(user_to_titan_string));

      // Clear previous content
      $('#channel_trees').html("");

      // Add lobby
      $('#channel_trees').append(
        '<div id="' + channel_tree.channel_lobby.id + '" class="lobby channel"><h1>' + channel_tree.channel_lobby.name + '</h1><ul id="lobby_userlist"></ul></div>'
      )
      // Add team channels
      $('#channel_trees').append('<div id="team_channels"></div>')
      for (channel of channel_tree.team_channels) {
        if (channel.users.length) { // Only draw teamchannel if it has users
          $('#team_channels').append(
            '<div id="' + channel.id + '" class="teams channel"><h2>' + channel.name + '</h2><ul id="' + channel.id + '_userlist"></ul><div id="' + channel.id + '_available"></div></div>'
          )
        }
      }

      // Sort channel list
      channel_tree.channel_lobby.users.sort((a, b) => a.name.localeCompare(b.name));
      for (channel of channel_tree.team_channels) {
        channel.users.sort((a, b) => a.name.localeCompare(b.name));
      }

      // Update list for each user
      for (const user of channel_tree.channel_lobby.users) {
        $('#lobby_userlist').append("<li class=\"user\">" + get_image_tag(user) + user.name + "</li>");
      }
      // Go through all channels...
      for (channel of channel_tree.team_channels) {
        // ...and all users in that channel
        for (const user of channel.users) {
          $('#' + channel.id + '_userlist').append("<li class=\"user\" id=\"" + user.id + "\">" + ordnances_selection_html_string + titans_selection_html_string + get_image_tag(user) + user.name + "</li>");
        }
      }
      update_according_to_selections(channel_tree, user_to_ordnance_string, user_to_titan_string);
    });

    function update_according_to_selections(channel_tree, user_to_ordnance_string, user_to_titan_string) {
      /* Update user choices based on selections by other users */

      // Make maps from the received strings created from maps
      var user_to_ordnance = new Map(JSON.parse(user_to_ordnance_string));
      var user_to_titan = new Map(JSON.parse(user_to_titan_string));

      // Set the according selection for the according users
      for (const [key, value] of user_to_ordnance.entries()) {
        $("#" + key).find(".dropbtn.ordnance").html('<img class="icon_image" src="/images/icons/ordnances/' + value + '.png" alt="' + value + '" width="30px" height="30px">');
      }
      for (const [key, value] of user_to_titan.entries()) {
        $("#" + key).find(".dropbtn.titan").html('<img class="icon_image" src="/images/icons/titans/' + value + '.png" alt="' + value + '" width="30px" height="30px">');
      }
      // Update available items
      for (channel of channel_tree.team_channels) {
        display_available_for_channel(channel.users, '#' + channel.id + '_available', user_to_ordnance, user_to_titan);
      }
    }
    socket.on('update selections', function (channel_tree, user_to_ordnance_string, user_to_titan_string) {
      update_according_to_selections(channel_tree, user_to_ordnance_string, user_to_titan_string);
    });

    function get_html_selection_string(name, id, options) {
      // Creates HTML string that contains list of `options`
      let html_string = '';
      html_string += '<div class="dropdown">';
      html_string += '<button class="dropbtn ' + id + '">' + name + '</button>';
      html_string += '<div class="dropdown-content">';
      // Add default empty selection
      html_string += '<button class="not_selected dropdown-menu-button" onclick="update_' + id + '(this);"><img class="icon_image" src="/images/icons/' + id + 's/not_selected.png" alt="not_selected" width="30px" height="30px"></button>';

      for (const option of options) {
        html_string += '<button class="' + option.id + ' dropdown-menu-button" onclick="update_' + id + '(this);"><img class="icon_image" src="/images/icons/' + id + 's/' + option.id + '.png" alt="' + option.name + '" width="30px" height="30px"></button>'
      }
      html_string += '</div>';
      html_string += '</div>';
      return html_string;
    }

    // Load ruleset
    var url = '/rules/ctf.json';
    var rules = {};
    $.ajax({
      type: 'GET',
      url: url,
      dataType: 'json',
      success: function (data) { rules = data; },
      async: false
    });

    // Apply rules
    ordnances_selection_html_string = get_html_selection_string('Ordnance', 'ordnance', rules.ordnances);
    titans_selection_html_string = get_html_selection_string('Titan', 'titan', rules.titans);

    // Get channel tree and selections on load
    window.onload = socket.emit('new client');
  </script>
</body>

</html>