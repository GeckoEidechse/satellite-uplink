<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Satellite Uplink</title>

  <!-- Icon-->
  <link rel="icon" href="/images/icons/favicon-circle.png">

  <!-- Local stylesheet -->
  <link href="styles.css" type="text/css" rel="stylesheet">
</head>

<body>
  <div id="channel_trees">
    <div id="lobby" class="channel">
      <h1>Waiting</h1>
      <ul id="lobby_userlist"></ul>
    </div>
    <div id="team_channels">
      <div id="team_a" class="teams channel">
        <h2>Militia</h2>
        <ul id="team_a_userlist"></ul>
      </div>
      <div id="team_b" class="teams channel">
        <h2>IMC</h2>
        <ul id="team_b_userlist"></ul>
      </div>
    </div>
  </div>

  <div id="callout_container">
    <label>
      Show callouts: <input type="checkbox" onchange="toggle_callout_display(this);" />
    </label>
    <div id="inner_callout_container">
    </div>
  </div>

  <div class="footer">Source on <a href="https://gitlab.com/GeckoEidechse/satellite-uplink">Gitlab</a></div>
  <!-- jQuery -->
  <script src="jquery.min.js"></script>

  <!-- Socket Library -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    function toggle_callout_display(checkbox) {
      // Clear HTML element
      $('#inner_callout_container').html("");
      // Show iframe if box is checked
      if (checkbox.checked) {
        $('#inner_callout_container').append('<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTvuwVzSbumH9uWgYxMVSfTOxzpzehRQlS9g9CQ8NFAHdGynYiQprnV5XXGznnxVBdjISy-dDNy3OkF/embed?start=false&loop=false&delayms=3000" frameborder="0" width="960" height="569" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>');
      }
    }
    var ordnances_selection_html_string = '';
    var titans_selection_html_string = '';
    var socket = io();

    function get_image_tag(user) {
      if (user.avatar)
        var url = "https://cdn.discordapp.com/avatars/" + user.id + "/" + user.avatar + ".png?size=256";
      else
        // If user has no icon, use default
        var url = "https://discord.com/assets/dd4dbc0016779df1378e7812eabaa04d" + ".png?size=256";

      let tag = " <img src=\"" + url + "\" alt=\"(" + user.name + "'s avatar)\" style=\"border-radius: 50%; width: 30px\"> "
      return tag;
    }

    function update_ordnance(select) {
      var ordnance_update = {
        ordnance: select.options[select.selectedIndex].value,
        user_id: select.parentElement.id
      }
      socket.emit('update ordnance', ordnance_update);
    }
    function update_titan(select) {
      var titan_update = {
        titan: select.options[select.selectedIndex].value,
        user_id: select.parentElement.id
      }
      socket.emit('update titan', titan_update);
    }

    function decrement_available(selection, id) {
      if (selection.id == id && selection.max_per_team != null) {
        var result = {
          "id": selection.id,
          "max_per_team": selection.max_per_team - 1
        };
        return result;
      }
      else
        return selection;
    }

    function get_current_available(channel_users, user_to_ordnance, user_to_titan) {
      // Clone object
      var rules_copy = jQuery.extend(true, {}, rules);
      for (const user of channel_users) {
        // Ordnance
        let ordnance_selection = user_to_ordnance.get(user.id);
        if (ordnance_selection) { // Only run if user selected something
          // Remove the selection from available
          rules_copy.ordnances = rules_copy.ordnances.map(function (element) {
            return decrement_available(element, ordnance_selection);
          });
        }
        // Titan
        let titan_selection = user_to_titan.get(user.id);
        if (titan_selection) { // Only run if user selected something
          // Remove the selection from available
          rules_copy.titans = rules_copy.titans.map(function (element) {
            return decrement_available(element, titan_selection);
          });
        }
      }
      return rules_copy;
    }

    function display_available_for_channel(channel_users, html_object_id, user_to_ordnance, user_to_titan) {
      var rules_copy = get_current_available(channel_users, user_to_ordnance, user_to_titan);
      var available_html_string = ''
      available_html_string += '<hr />' + '<h3>Available:</h3>' + '<br />' + '<b>Ordnances</b>' + '<ul>'
      for (const ordnance of rules_copy.ordnances) {
        if (ordnance.max_per_team > 0 || ordnance.max_per_team == null) {
          available_html_string += '<li>' + '<img src="/images/icons/ordnances/'+ ordnance.id +'.png" width="30px" height="30px"></img> ' + ordnance.id + '</li>';
        }
      }
      available_html_string += '</ul>' + '<b>Titans</b>' + '<ul>'
      for (const titan of rules_copy.titans) {
        if (titan.max_per_team > 0 || titan.max_per_team == null) {
          available_html_string += '<li>'+ '<img src="/images/icons/titans/'+ titan.id +'.png" width="30px" height="30px"></img> ' + titan.id + '</li>';
        }
      }
      available_html_string += '</ul>'
      $(html_object_id).append(available_html_string);
      for (const ordnance of rules_copy.ordnances) {
        if (ordnance.max_per_team < 0 && ordnance.max_per_team != null) {
          $(html_object_id).append('<p style="color: red">Too many: ' + ordnance.id + ' !</p>');
        }
      }
      for (const titan of rules_copy.titans) {
        if (titan.max_per_team < 0 && titan.max_per_team != null) {
          console.log('Too many: ' + titan.id);
          $(html_object_id).append('<p style="color: red">Too many: ' + titan.id + ' !</p>');
        }
      }
    }

    // Call when channel tree has changed
    socket.on('update channel tree', function (channel_tree, user_to_ordnance_string, user_to_titan_string) {

      // Make maps from the received strings created from maps
      var user_to_ordnance = new Map(JSON.parse(user_to_ordnance_string));
      var user_to_titan = new Map(JSON.parse(user_to_titan_string));

      // Clear previous content
      $('#lobby_userlist').html("");
      $('#team_a_userlist').html("");
      $('#team_b_userlist').html("");

      // Sort channel list
      channel_tree.channel_lobby.users.sort((a, b) => a.name.localeCompare(b.name));
      channel_tree.channel_a.users.sort((a, b) => a.name.localeCompare(b.name));
      channel_tree.channel_b.users.sort((a, b) => a.name.localeCompare(b.name));

      // Update list for each user
      for (const user of channel_tree.channel_lobby.users) {
        $('#lobby_userlist').append("<li class=\"user\">" + get_image_tag(user) + user.name + "</li>");
      }
      for (const user of channel_tree.channel_a.users) {
        $('#team_a_userlist').append("<li class=\"user\" id=\"" + user.id + "\">" + ordnances_selection_html_string + titans_selection_html_string + get_image_tag(user) + user.name + "</li>");
      }
      for (const user of channel_tree.channel_b.users) {
        $('#team_b_userlist').append("<li class=\"user\" id=\"" + user.id + "\">" + ordnances_selection_html_string + titans_selection_html_string + get_image_tag(user) + user.name + "</li>");
      }
      // Set the according selection for the according users
      for (const [key, value] of user_to_ordnance.entries()) {
        document.getElementById(key).childNodes[1].value = value; // TODO: don't statically assume the wanted child is the second elem in list
      }
      for (const [key, value] of user_to_titan.entries()) {
        document.getElementById(key).childNodes[3].value = value; // TODO: don't statically assume the wanted child is the second elem in list
      }
      // Update available items
      display_available_for_channel(channel_tree.channel_a.users, '#team_a_userlist', user_to_ordnance, user_to_titan);
      display_available_for_channel(channel_tree.channel_b.users, '#team_b_userlist', user_to_ordnance, user_to_titan);
    });

    function get_html_selection_string(name, id, options) {
      // Creates HTML string that contains list of `options`

      var selection_html_string = '<label>' + name + '</label><select onchange="update_' + id + '(this)">';
      // Add default empty selection
      selection_html_string += '<option value="not_selected">not_selected</option>';
      for (const option of options) {
        selection_html_string += '<option value="' + option.id + '">' + option.id + '</option>';
      }
      // Close tag
      selection_html_string += '</select>';
      return selection_html_string;
    }

    // Load ruleset
    var url = '/rules.json';
    var rules = {};
    $.ajax({
      type: 'GET',
      url: url,
      dataType: 'json',
      success: function (data) { rules = data; },
      async: false
    });

    // Apply rules
    ordnances_selection_html_string = get_html_selection_string('Ordnance', 'ordnance', rules.ordnances);
    titans_selection_html_string = get_html_selection_string('Titan', 'titan', rules.titans);

    // Get channel tree and selections on load
    window.onload = socket.emit('new client');
  </script>
</body>

</html>